<!-- markdownlint-disable MD033 -->
<!-- markdownlint-disable MD024 -->

# Process

Library for running child processes.

## Usage

```luau
local process = require("@std/process")

-- run a simple program with args
local result = process.run {
    program = "markdownlint-cli2",
    args = { "--fix", "myfile.md" },
}

-- a shell command
local files = process.shell("ls -l"):unwrap()

-- a long running child process
local child = process.spawn({
    program = "someutil --watch",
    shell = "sh",
})

for line in child.stdout:lines() do
    local thing_changed = line:match("([%w]+) changed!")
    print(`Change detected: {thing_changed}`)
end
```

`function process.run(options: RunOptions): RunResult`

<details>

<summary> See the docs </summary

Runs a program, yields until it completes, and returns its results.

Takes a RunOptions table:

```luau
    type RunOptions = {
        program: string,
 optional args you want to pass
        args: { string }?,
 the name or path of the shell, omit to run without shell
        shell: string?
 path to the the working directory you want your command to execute in
        cwd: string?,
    }
```

### Blocks

Until the process exits.

### Usage

```luau
    local process = require("@std/process")
    local result = process.run {
        program = "lune",
        args = {"run", somefile},
    }
    if result.ok then
        print(result.stdout)
    end
```

</details>

`function process.shell(command: string): RunResult`

<details>

<summary> See the docs </summary

Launches a shell command in a child process.

Uses the same shell you're using to run `seal` (so your aliases should available, except on Windows,
where it's a bit more complicated).

To find your current shell, `process.shell` checks your `SHELL` environment variable, and
if not found, defaults to `sh` on Unix-like systems and `powershell` (Windows PowerShell) on Windows.

On Windows, arguments aren't necessarily separated by whitespace like on Linux, and every program
might accept arguments in a slightly different way, so be careful and use `process.run` with `args`
when in doubt.

Note that spawning processes (even starting the `powershell` process) is slow on Windows,
so I recommend sticking to `process.run` with `args` unless you need shell behavior for your usecase.

### Usage

```luau
    local process = require("@std/process")
    local file_stuff: {string} = process.shell("ls -l"):unwrap()
    print(file_stuff)
```

</details>

`function process.spawn(options: SpawnOptions): ChildProcess`

<details>

<summary> See the docs </summary

Spawns a long-running process in a non-blocking manner, returns a `ChildProcess` that contains handles to the spawned process' stdout, stderr, and stdin.

## Usage

```luau
    local process = require("@std/process")
    local child = process.spawn({
        program = "someutil --watch",
        shell = "sh",
    })

    for line in child.stdout:lines() do
        local thing_changed = line:match("([%w]+) changed!")
        print(`Change detected: {thing_changed}`)
    end
```

</details>

`function process.setexitcallback((number): ()): ()`

`function process.exit(code: number?): never`

`RunResult.ok: true`

`RunResult.out: string`

 cleaned standard output of the process, shouldn't have trailing newlines or whitespace

`RunResult.stdout: string`

 the raw standard output (stdout) generated by the process; this includes trailing newlines and whitespace

`RunResult.stderr: string`

 the raw standard error (stderr) generated by the process; this includes trailing newlines and whitespace

`RunResult.ok: false`

`RunResult.err: string`

`RunResult.stdout: string`

`RunResult.stderr: string`

`function RunResult.unwrap(self: RunResult): string`

 Returns the `RunResult`'s `stdout` if it was successful, stripping trailing whitespace and newlines.
 Errors if the RunResult was unsuccessful.

`function RunResult.unwrap_or(self: RunResult, default: string | (result: RunResult): string): string`

Returns the `RunResult`'s `stdout` if it was successful, otherwise returns a default value.

The `default` can be either a string or a function that takes in the `RunResult` and returns a string.
If you provide a `default` function, `:unwrap_or` will return what it returns.

`RunOptions.program: string`

`RunOptions.args: { string }?`

 an optional list of arguments to pass into the program; on Windows, you should use this instead of trying to pass whitespace-separated arguments in `program`

`RunOptions.shell: string?`

 specify a shell to run the program with; otherwise runs it as a bare process with no shell

`RunOptions.cwd: string?`

 path to the the working directory you want your command to execute in, defaults to your shell's cwd

`SpawnOptions.program: string`

 the program you want to run, must be available in $PATH or be an absolute path to an executable

`SpawnOptions.args: { string }?`

 an optional list of arguments to pass into the program; on Windows, you should use this instead of trying to pass whitespace-separated arguments in `program`

`SpawnOptions.shell: string?`

`SpawnOptions.cwd: string?`

 path to the the working directory you want your command to execute in, defaults to your shell's cwd

`stream: {`

<details>

<summary> See the docs </summary

A `ChildProcessStream` captures incoming bytes from your `ChildProcess`' output streams (either stdout or stderr),
and caches them in its `inner` buffer. Each stream is spawned in a separate Rust thread to facilitate
consistently nonblocking, dependable reads, allowing most `ChildProcess.stream:read` methods to be fully nonblocking unless
specifically requested otherwise.

## Options

### Stream capacity

To prevent memory leaks (if you spawn a child process and never read from stdout or stderr), each stream's inner buffer capacity is capped,
and adjustable by setting `stdout_capacity` and `stderr_capacity`, respectively.

By default, `stdout` streams are capped to 2048 bytes and `stderr` streams to 1028.

When more bytes are read from the stream than can fit in the buffer, old bytes are drained (and lost!) so the buffer
can remain the same size (preventing memory leaks).

By increasing stream capacity, you allow more bytes to be read/consumable at the same time without losing data if you infrequently read from the buffer.

If you're reading from stdout in really tight loops, and your ChildProcess only spits out data in chunks of 512 bytes at a time, you can definitely
decrease your stream capacity to 512 bytes (or slightly larger just in case), to reduce allocations.

## Truncation

By default, seal truncates bytes from the front of inner, causing old data to be lost first. Set `truncate == "back"` to override this behavior (and preserve old data at the expense of incoming data)

</details>

`stream.stdout_capacity: number?`

 inner buffer capacity of `ChildProcess.stdout`, default 2048

`stream.stderr_capacity: number?`

 inner buffer capacity of `ChildProcess.stderr`, default 1024

`stream.stdout_truncate: ("front" | "back")?`

 what side of stdout should be truncated when full? defaults to "front"

`stream.stderr_truncate: ("front" | "back")?`

 what side of stderr should be truncated when full? defaults to "front"

`stream.}?`

`export type ChildProcessStream = setmetatable<{`

 Represents the stdout and stderr streams of a `ChildProcess`, both ran in parallel threads
 and streamed for nonblocking behavior.

`ChildProcessStream.--> stream:read(count: number?, timeout: number?): string?`

`function ChildProcessStream.read(self: ChildProcessStream, count: number?, timeout: number?): string?`

<details>

<summary> See the docs </summary

Reads up to `count` bytes from the stream for up to `timeout` seconds, retrying while the stream remains empty.

- If `count` is unspecified or nil, reads the entire stream instead of stopping at `count` bytes.
- If `timeout` is unspecified or nil, keeps retrying *forever* while the stream is empty and the reader is still alive.
- If `timeout > 0`, keeps retrying for `timeout` seconds while the stream is empty and the reader is still alive.

### Returns

Returns as soon as anything gets written to the stream, consuming and returning the available bytes without
any intermediate utf8 coercion/validation. Returns `nil` if `timeout` seconds elapse and the stream remains empty.

If you want to wait until a specific number of bytes are available, use `:read_exact` instead.

### Blocks

Blocks the current VM until the stream's not empty, `timeout` seconds elapse, or the reader thread exits.

To prevent this function from blocking, pass a `timeout` of 0 seconds!

## Usage

Keep reading until data appears (default behavior):

```luau
        local first_message = child.stdout:read() :: string
        print(first_message)
```

Read the first 256 bytes once data appears:

```luau
        local first_part = child.stdout:read(256) :: string
```

Get everything currently in the stream without blocking:

```luau
        local current_data = child.stdout:read(nil, 0.0)
```

</details>

`ChildProcessStream.--> stream:read_exact(count: number, timeout: number?): string?`

`function ChildProcessStream.read_exact(self: ChildProcessStream, count: number, timeout: number?): string?`

<details>

<summary> See the docs </summary

Reads exactly `count` bytes from the stream, retrying until `count` bytes are available or `timeout` seconds elapse.

Bytes are not consumed from the stream until exactly `count` bytes are available.

- If `timeout` is unspecified or nil, keeps retrying *forever* while the stream is empty and the reader is still alive.
- If `timeout > 0`, keeps retrying for `timeout` seconds while the stream is empty and the reader is still alive.

### Returns

A string of exactly `count` length without any intermediate utf-8 coercion/validation, or `nil` if exactly `count` bytes couldn't be read from the stream.

### Blocks

Blocks the current VM until `count` bytes are found, `timeout` seconds elapse, or the reader thread exits.

Pass a timeout of `0` seconds to make this function nonblocking.

## Usage

Read exactly 512 bytes as soon as 512 bytes are available:

```luau
        local first_512 = child.stdout:read_exact(512)
```

Read from both streams every 0.5 seconds, byte by byte, without otherwise blocking the VM:

```luau
        local stdout_chars: { string } = {}
        local stderr_chars: { string } = {}
        while time.wait(0.5) and child:alive() do
            local stdout_char = child.stdout:read_exact(1, 0.0)
            if stdout_char then
                table.insert(stdout_chars, stdout_char)
            end
            local stderr_char = child.stderr:read_exact(1, 0.0)
            if stderr_char then
                table.insert(stderr_chars, stderr_char)
            end
        end
```

</details>

`ChildProcessStream.--> stream:read_to(term: string, inclusive: boolean?, timeout: number?, allow_partial: boolean?): string?`

`function ChildProcessStream.read_to(self: ChildProcessStream, term: string, inclusive: boolean?, timeout: number?, allow_partial: boolean?): string?`

<details>

<summary> See the docs </summary

Keep reading from the stream until search `term` is encountered. This is especially useful if you're trying to read line-by-line,
or until a specific delimiter is encountered.

By default, blocks the current VM (Rust Thread) until `term` is found, and doesn't consume any bytes from the stream until `term` is found.

- If `inclusive == true`, includes `term` with the resulting string, otherwise strips it from the result.
- If `timeout` is specified, `allow_partial` is unspecified or false, and `term` isn't found before `timeout` seconds elapse, returns `nil` without consuming any bytes from the stream.
- If `timeout` is specified, `allow_partial` is true, and `term` isn't found before `timeout` seconds elapse, consumes and returns the entire contents of the stream.
- `allow_partial` doesn't do anything if `timeout` is unspecified.

### Returns

The stream's contents without any intermediate utf8 conversion/validation.
Returns `nil` if `timeout` elapses and the search term hasn't been found.

### Blocks

Blocks the current VM until `term` is found, `timeout` seconds elapse, or the reader thread exits.

</details>

`ChildProcessStream.--> stream:fill(target: buffer, target_offset: number?, timeout: number?): number`

`function ChildProcessStream.fill(self: ChildProcessStream, target: buffer, target_offset: number?, timeout: number?): number`

<details>

<summary> See the docs </summary

Fill the `target` buffer with as many bytes as possible from the stream. Retries until the stream is nonempty or `timeout` seconds elapse.

- `target_offset` defaults to `0` if unspecified or nil.

### Returns

The number of bytes successfully consumed from the stream and read into the `target` buffer.

This function returns as soon as anything is written to the stream; use `:fill_exact` instead to return as soon as a specific number
of bytes are available in the stream.

### Errors

- If `target_offset` is greater than the buffer's length.

This function should not overfill the target buffer! A maximum of `buffer.len(target) - buffer_offset` bytes should be consumed.

## Usage

```luau
        local buffy = buffer.create(1024)
        local offset = 0
        while child:alive() and offset < 1024 do
            local count = child.stdout:fill(buffy, offset)
            offset += count
        end
```

</details>

`ChildProcessStream.--> stream:fill_exact(count: number, target: buffer, target_offset: number?, timeout: number?): boolean`

`function ChildProcessStream.fill_exact(self: ChildProcessStream, count: number, target: buffer, target_offset: number?, timeout: number?): boolean`

<details>

<summary> See the docs </summary

Read exactly `count` bytes into the `target` buffer at `target_offset`, retrying until `count` bytes are available or `timeout` seconds elapse.

- `target_offset` defaults to `0` if unspecified or nil.

### Returns

`true` if `count` bytes were successfully read and consumed from the stream, `false` otherwise.

### Errors

- If `target_offset` + `count` > buffer length - 1; this usually means a logic bug. Remember to clamp your offsets!

### Blocks

Blocks the current VM until `count` bytes are available in the stream or `timeout` seconds elapse.

Pass a `timeout` of `0` seconds to prevent this function from blocking!

</details>

`ChildProcessStream.--> stream:len(): number`

`function ChildProcessStream.len(self: ChildProcessStream): number`

 Returns the current length/size of the stream's inner buffer.

`ChildProcessStream.--> stream:capacity(): number`

`function ChildProcessStream.capacity(self: ChildProcessStream): number`

 Returns the maximum capacity of the stream's inner buffer.

`ChildProcessStream.--> for line in stream:lines(timeout: number?)`

`function ChildProcessStream.lines(self: ChildProcessStream, timeout: number?): ((): string)`

<details>

<summary> See the docs </summary

Iterate over the lines in the stream, blocking the current VM (Rust Thread) until all lines are read or the timeout has been reached.

If a `timeout` is specified, `:lines()` will stop iterating once a line hasn't been seen for `timeout` seconds, allowing you to
early-interrupt when new data hasn't been seen for a while.

Unlike `:iter`, this method cleans up `\r` prefixes and trailing `\n`s.

## Usage

### In a loop

```luau
        local process = require("@std/process")
        local child = process.spawn({
            program = "someutil --watch",
            shell = "sh",
        })

        for line in child.stdout:lines() do
            local thing_changed = line:match("([%w]+) changed!")
            print(`Change detected: {thing_changed}`)
        end
```

### As iterator

```luau
        local process = require("@std/process")
        local child = process.spawn {
            program = "somewatcher --watch",
            shell = "sh",
        }

        local next_line = child.stdout:lines()
        local first_line = next_line()
        local second_line = next_line()
```

</details>

`ChildProcessStream.--> for message in stream:iter(timeout: number?, write_delay_ms: number?)`

`function ChildProcessStream.iter(self: ChildProcessStream, timeout: number?, write_delay_ms: number?): (): string`

<details>

<summary> See the docs </summary

Iterate over the stream with more granular options:

To prevent nonterminating iteration without an explicit `break`, you can provide a `timeout`, which stops iteration
when new data hasn't been seen for `timeout` seconds.

When iteration attempts to read from an empty stream, it waits `write_delay_ms` milliseconds (default 5) before trying again.
Increase this value if you see weird chunking behavior (you want to see more data each iteration),
or decrease this value if your child process outputs quickly and you want iteration to go faster.

This function does *not* strip preceding '\r's and trailing '\n's (unlike `:lines()` and generalized iteration).

</details>

`ChildProcessStream.--> for line in stream`

`function ChildProcessStream.__iter(self: ChildProcessStream): (): string`

Iterate over the lines of the `ChildProcessStream` with generalized iteration, blocking until `break` or the reader thread exits.

Basically equivalent to `ChildProcessStream:lines()` except with generalized iteration you can't specify a `timeout`.

`function ChildProcessStream.write(self: ChildProcessStdin, data: string): error?`

Attempts to write to the child process' stdin; if an error occurs (usually a broken pipe), returns a seal `error` userdata.

`function ChildProcessStream.close(self: ChildProcessStdin): ()`

<details>

<summary> See the docs </summary

Explicitly closes the child process stdin; this signals EOF for some programs that read multiple lines from stdin.

Errors if it can't flush the child process' stdin before closing.

## Usage

```luau
        local child = process.spawn {
            program = "python3",
            args = { "-" },
        }
        child.stdin:write(PYTHON_SRC)
        child.stdin:close()
```

</details>

`ChildProcess.id: number`

`function ChildProcess.alive(self: ChildProcess): boolean`

`function ChildProcess.kill(self: ChildProcess): ()`

`stdout: ChildProcessStream`

`stderr: ChildProcessStream`

`stdin: ChildProcessStdin`
