<!-- markdownlint-disable MD033 -->
<!-- markdownlint-disable MD024 -->

# fs.dir

`local dir = require("@std/fs/dir")`

---

## `export type` DirectoryEntry

<h4>

```luau
export type DirectoryEntry = common_types.DirectoryEntry
```

</h4>

---

## `export type` DirectoryBuilder

<h4>

```luau
export type DirectoryBuilder = common_types.DirectoryBuilder
```

</h4>

---

## `export type` DirLib

<h4>

```luau
export type DirLib = setmetatable<{
```

</h4>

---

### DirLib.from

<h4>

```luau
function DirLib.from(path: string) -> DirectoryEntry,
```

</h4>

 Creates a `DirectoryEntry` from the directory at `path`, erroring if the directory is NotFound/PermissionDenied, etc.

---

### DirLib.build

<h4>

```luau
function DirLib.build(name: string, tree: DirectoryTree) -> DirectoryBuilder,
```

</h4>

 Returns a `DirectoryBuilder` table for `fs.readtree`, `fs.writetree`, etc.

---

### DirLib.create

<h4>

```luau
function DirLib.create(path: string) -> DirectoryEntry,
```

</h4>

 Creates a *new* directory at `path`, erroring if an entry already exists there.

---

### DirLib.ensure

<h4>

```luau
function DirLib.ensure(path: string, create_missing: boolean?) -> DirectoryEntry,
```

</h4>

<details>

<summary> See the docs </summary

Ensures that a directory exists at `path` by trying to create it, catching any AlreadyExists error, and returning a `DirectoryEntry` at that path.

Similar to `fs.makedir(path, { error_if_exists = false }); fs.dir.from(path)`

## Usage

```luau
-- doesn't replace .vscode if it already exists, but creates it if it doesn't
local dot_vscode = fs.dir.ensure(".vscode")
local settings_json = dot_vscode:find("settings.json"):try_file()
```

</details>

---

### DirLib.try_remove

<h4>

```luau
function DirLib.try_remove(path: string) -> (boolean, "Ok" | "PermissionDenied" | "NotFound" | "NotADirectory" | "Other", string?),
```

</h4>

<details>

<summary> See the docs </summary

Try to remove directory at `path` using Rust's `fs::remove_dir_all` without erroring in common cases.

If this function partially fails (removes some but not all subtrees/files in `path`), `try_remove` will return false
with result "Other", as well as an error kind string that describes what went wrong.

## Errors

- if provided invalid arguments (`path` is not a valid utf-8 encoded string that could exist on the filesystem)

</details>

---

### DirLib.home

<h4>

```luau
function DirLib.home() -> DirectoryEntry,
```

</h4>

Returns a `DirectoryEntry` corresponding to the user's home directory, erroring if not found.

## Usage

```luau
local zip_downloads = fs.dir.home()
    :expect_dir("Downloads")
    :list(false, function(path: string)
        return str.endswith(path, ".zip")
    end)
```

---

### DirLib.cwd

<h4>

```luau
function DirLib.cwd() -> DirectoryEntry,
```

</h4>

Constructs a `DirectoryEntry` from the user's current working directory (cwd)

If you're looking for project-relative pathing, I recommend using `fs.dir.project()` instead, as those will work no matter
where the user is when they execute your code.

---

### DirLib.project

<h4>

```luau
function DirLib.project(n: number?) -> DirectoryEntry,
```

</h4>

<details>

<summary> See the docs </summary

Constructs a `DirectoryEntry` from the script's current *seal* project.

Use this for most project-relative paths instead of `fs.path.cwd` or `fs.dir.cwd` usages.

## Errors

- if a *seal* project couldn't be found exactly `n` project parents relative to `script:path()`.
- use `fs.path.project` instead if you want to get the *seal* project without erroring.

## Usage

```luau
local fs = require("@std/fs")
local str = require("@std/str")

local input_files = fs.dir.project()
    :expect_dir("input")
    :list(false, function(path: string)
        return str.endswith(path, ".csv")
    end)
```

</details>

---

### DirLib.__call

<h4>

```luau
function DirLib.__call(self: any, path: string) -> DirectoryEntry?,
```

</h4>

Convenient and slightly more efficient alternative to `fs.find(path):try_dir()`

## Usage

```luau
local src_dir = fs.dir("./src")
if src_dir then
    local main_luau = src_dir:expect_file("main.luau")
    main_luau:append('print("meow")')
end
```

---

Autogenerated from [std/fs/dir.luau](/.seal/typedefs/std/fs/dir.luau). *seal* is best experienced with inline, in-editor documentation. Please see the linked typedefs file if this documentation is confusing, too verbose, or inaccurate.
