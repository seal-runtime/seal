{
  "@seal/globaltype/interrupt.code": {
    "documentation": "What caused this interrupt (either CtrlC or CtrlD)"
  },
  "@seal/globaltype/TimeSpan.duration": {
    "documentation": "Convert this `TimeSpan` into a `Duration` so you can easily get total number of years/months/etc. in the `TimeSpan`."
  },
  "@seal/globaltype/Duration": {
    "keys": {},
    "documentation": "Represents a signed duration of time. Make these by calling functions from the `@std/time` library.\n"
  },
  "@seal/globaltype/DateTime.timespan": {
    "documentation": "Get the `TimeSpan` between this DateTime and another.\n\nIf `other` is a DateTime in the future, the result is a positive `TimeSpan`, otherwise it'll be negative (recommend using `DateTime:since` instead).\n\nNote that because `TimeSpans` store seconds/minutes/days/etc. separately, you have to call `TimeSpan:duration()` to get a `Duration` first to figure out how many days/seconds/etc. are in between two DateTimes.\"\n"
  },
  "@seal/globaltype/DateTime": {
    "keys": {
      "timespan": "@seal/globaltype/DateTime.timespan",
      "to": "@seal/globaltype/DateTime.to",
      "unix_timestamp": "@seal/globaltype/DateTime.unix_timestamp",
      "timezone": "@seal/globaltype/DateTime.timezone",
      "in_timezone": "@seal/globaltype/DateTime.in_timezone",
      "format": "@seal/globaltype/DateTime.format",
      "since": "@seal/globaltype/DateTime.since"
    },
    "documentation": "Represents a Timezone-aware moment in date and time.\n\n- To make a new `DateTime`, use `@std/time/datetime`'s `now` or `parse` functions.\n- Use `DateTime:format` to format a datetime by passing in a strftime format string or COMMON_FORMAT.\n- To do arithmetic on a `DateTime`, add or subtract a `TimeSpan` from it.\n- Use `DateTime:since`, `DateTime:to`, and `DateTime:timespan` to get `TimeSpan`s between two `DateTime`s.\n- You can also compare `DateTime`s using the standard `>`, `<`, `<=`, `>=`, and `==` operators.\n## Usage\n\n```luau\nlocal datetime = require(\"@std/time/datetime\")\nlocal yesterday = datetime.now() - datetime.days(1)\nprint(yesterday:format(\"ISO_8601\"))\n```\n"
  },
  "@seal/globaltype/TimeSpan.units": {
    "documentation": "Get the individual units in the internal representation of this `TimeSpan`. This is probably not what you want."
  },
  "@seal/global/_VERSION": {
    "keys": {},
    "documentation": "version of both Luau (best that we know, since luau doesn't officially publish _VERSION at runtime) and seal"
  },
  "@luau/global/table": {
    "keys": {
      "concat": "@luau/global/table.concat",
      "remove": "@luau/global/table.remove"
    },
    "documentation": "Luau's builtin table library, mostly focused on array-like table manipulation.\n\n- Use `table.insert` to append or insert elements,\n- `table.find` to check if/where an element exists in an array,\n- `table.remove` to remove elements (watch the footgun w/ `table.find`),\n- `table.concat` to concatenate `{ string }`s into strings. This is the fastest way to concat strings.\n"
  },
  "@seal/global/pp": {
    "keys": {},
    "documentation": "Pretty print for pretty tables (also returns, unlike `print`)."
  },
  "@luau/global/table.remove": {
    "documentation": "- `table.remove(t, index)` removes and returns the element at `index`\n- `table.remove(t)` removes and returns the last element of your array (everyone considers this a mistake)\n## footgun\n- Don't do the `table.remove(t, table.find(t, element))` footgun.\n- If the `table.find` call doesn't find anything, it returns `nil`, causing `table.remove` to pop the back element of your array `t` without warning.\n\nThe Luau team can't fix this because of backwards bug-for-bug compatibility :/\n"
  },
  "@seal/global/script.path": {
    "documentation": "Path to the current script, also internally used as the chunk/debug name for this file in seal."
  },
  "@seal/globaltype/DateTime.format": {
    "documentation": "Format this `DateTime` with strftime format strings or COMMON_FORMATs.\n## Usage\n```luau\nlocal datetime = require(\"@std/time/datetime\")\nlocal now = datetime.now()\nprint(now:format(\"ISO_8601\")) --> 2025-08-23 14:57\nprint(now:format(\"%A\")) --> Saturday\n```\n## Valid strftime format specifiers (Rust Jiff-compatible):\n- %a  - Abbreviated weekday name (e.g., Sun)\n- %A  - Full weekday name (e.g., Saturday)\n- %b  - Abbreviated month name (e.g., Aug)\n- %B  - Full month name (e.g., August)\n- %c  - Locale-specific date and time (e.g., Sat Aug 23 15:01:00 2025)\n- %d  - Day of the month (01-31)\n- %H  - Hour in 24h format (00-23)\n- %I  - Hour in 12h format (01-12)\n- %j  - Day of the year (001-366)\n- %m  - Month as a number (01-12)\n- %M  - Minute (00-59)\n- %p  - AM or PM\n- %Q  - IANA time zone name (e.g., America/Chicago)\n- %S  - Second (00-59)\n- %U  - Week number of the year (Sunday as first day of week)\n- %w  - Weekday as a number (0-6, Sunday is 0)\n- %W  - Week number of the year (Monday as first day of week)\n- %x  - Locale-specific date (e.g., 08/23/25)\n- %X  - Locale-specific time (e.g., 15:01:00)\n- %y  - Year without century (00-99)\n- %Y  - Year with century (e.g., 2025)\n- %%  - Literal percent sign\n"
  },
  "@seal/globaltype/TimeSpan.relative_to": {
    "documentation": "The `DateTime` this `TimeSpan` is relative to, or nil if it's not relative to any."
  },
  "@seal/globaltype/DateTime.in_timezone": {
    "documentation": "Returns a new `DateTime` representing the same instant in time but in a different timezone."
  },
  "@seal/globaltype/error": {
    "keys": {},
    "documentation": "A wrapped error returned by mluau's `pcall` or seal, can be tostringed.\nTo interact with errors (and make your own), use `@std/err`\n## Usage\n```luau\nlocal success, result = pcall(myfn)\nif typeof(result) == \"error\" then\n    print(tostring(result)) -- result is an error message\nelse\n    -- result should be narrowed to the return type of myfn\nend\n```\n"
  },
  "@seal/global/warn": {
    "keys": {},
    "documentation": "Prints a yellow warning to stderr."
  },
  "@luau/global/table.concat": {
    "documentation": "Fastest way to concatenate strings in Luau. Don't do loops of ..=, just use this."
  },
  "@seal/global/pcall": {
    "keys": {},
    "documentation": "Call `protected_callback` safely without blowing up if it errors.\n<br>\nUnlike base Luau, seal returns an `error` type when `pcall` fails, allowing for slightly better error handling.\n## Usage\n```luau\nlocal success, result = pcall(function(): string -- return type when it succeeds\n    return maybestringmaybekaboom()\nend)\nif typeof(result) == \"error\" then\n    print(`got error: {result}`)\nelse\n    -- result should be narrowed to `string` here\nend\n```\n### I don't want to return anything\n- Set the return type to `nil` instead of `()`\n### Multirets\n- Should be supported at runtime, but you probably want to cast `pcall` to `any` to appease the typechecker.\n"
  },
  "@seal/global/script": {
    "keys": {
      "parent": "@seal/global/script.parent",
      "path": "@seal/global/script.path",
      "entry_path": "@seal/global/script.entry_path"
    },
    "documentation": "The file you're currently working on. Has the extremely useful method `:parent()`\nwhich you can use to get the directory your file resides in.\n"
  },
  "@seal/global/script.entry_path": {
    "documentation": "Path to the file or executable the user ran with seal ./myfile.luau, seal run, etc."
  },
  "@seal/globaltype/DateTime.to": {
    "documentation": "Get the `TimeSpan` between this DateTime and another (preferably in the future).\n## Usage\n```luau\nlocal datetime = require(\"@std/time/datetime\")\nlocal now = datetime.now()\nlocal jan_01 = datetime.parse(`{now.year + 1}-01-01 00:00`, \"ISO_8601\", \"UTC\")\nprint(`Days until next year: {math.round(now:to(jan_01):duration().days}`))\n```\n"
  },
  "@seal/global/script.parent": {
    "documentation": "Path to this file's parent in the filesystem. Very useful if you want to write a script that saves something right next to it (tests!!)\n## Usage\n\n```luau\nlocal fs = require(\"@std/fs\")\nfs.writefile(fs.path.join(script:parent(), \"meow.txt\"), \"meow\")\n```\n"
  },
  "@seal/globaltype/TimeSpan": {
    "keys": {
      "duration": "@seal/globaltype/TimeSpan.duration",
      "relative_to": "@seal/globaltype/TimeSpan.relative_to",
      "units": "@seal/globaltype/TimeSpan.units"
    },
    "documentation": "A calendar-aware Duration type, composed of individual separate time units.\n- To create a `TimeSpan`, use `@std/time/datetime`'s `hours/days/seconds/etc.` functions.\n- You use these to add/subtract with `DateTimes` to shift them forwards or backwards in time.\n- Use `TimeSpan:duration()` to get the total number of days/minutes/hours/etc. in the `TimeSpan`.\n## Usage\n```luau\nlocal datetime = require(\"@std/time/datetime\")\nlocal last_week = datetime.now() - datetime.days(7)\n```\n## Warnings\n### 1. You can't compare `TimeSpan`s.\n- `time.hours(24)` and `time.days(1)` are have equivalent `Duration`s but aren't the same `TimeSpan`.\n- Check the *jiff* documentation to see why they don't allow `Span` comparisons.\n### 2. Specify `relative_to` for `datetime.months` or `datetime.years` for `TimeSpan` arithmetic.\n\n- These 2 are calendar aware and can change duration depending on the DateTime they're relative to.\n- If you're simply doing `datetime.now() + datetime.years(1)` you're fine.\n- But if you're adding `TimeSpans` to each other you need to do something like `datetime.months(2, datetime.now()) + datetime.days(3)`\n"
  },
  "@seal/globaltype/interrupt": {
    "keys": {
      "code": "@seal/globaltype/interrupt.code"
    },
    "documentation": "An intercepted user interrupt, either Ctrl-C or Ctrl-D.\n"
  },
  "@seal/globaltype/DateTime.since": {
    "documentation": "Get the `TimeSpan` between this DateTime and another (preferably in the past).\n## Usage\n```luau\nlocal datetime = require(\"@std/time/datetime\")\nlocal now = datetime.now()\nlocal jan_01 = datetime.parse(`{now.year}-01-01 00:00`, \"ISO_8601\", \"UTC\")\nprint(`Days in year to date: {math.round(now:since(jan_01):duration().days}`))\n```\n"
  },
  "@seal/global/p": {
    "keys": {},
    "documentation": "Simple print (no colors, less formatting) and returns."
  },
  "@seal/global/_SEAL_VERSION": {
    "keys": {},
    "documentation": "seal's version"
  },
  "@seal/global/dp": {
    "keys": {},
    "documentation": "Debug print; use this to investigate pesky non-utf8 codes in strings, see the source/line/function of\nthings causing trouble, etc. Also returns what it prints.\n<br>\nAdd a `__dp` function to your custom type's metatable to customize its debug print output.\n"
  },
  "@seal/global/channel": {
    "keys": {},
    "documentation": "A global that exists in child threads.\n<br>\nAccess startup data passed by the parent thread with `channel.data`\n## Message passing\n- Send a data message back to parent thread: `channel:send` with automatic (json) serialization\n- Send a buffer back to the parent thread: `channel:sendbytes`\n- Read messages from the parent thread: `channel:read` and `channel:read_await`\n- Read a buffer message sent from the parent thread: `channel:readbytes` and `channel:readbytes_await`\nSee `@std/thread`'s `JoinHandle` docs for more information. Channel methods are basically the same as their `JoinHandle` equivalents.\n## Usage\n```luau\nif channel then -- make sure we're in a child thread\n    local data = channel.data\n    local result: { string } = {}\n    if data then\n        -- logic\n    end\n    channel:send(result)\nend\n```\n"
  },
  "@seal/globaltype/DateTime.timezone": {
    "documentation": "The IANA timezone for this DateTime. All DateTimes *must* have a timezone!"
  },
  "@seal/globaltype/DateTime.unix_timestamp": {
    "documentation": "Time, in seconds, since the Unix epoch (January 1st, 1970 at 00:00 UTC)"
  }
}